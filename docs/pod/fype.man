.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FYPE 1"
.TH FYPE 1 "2008-10-19" "Fype v0.1-devel Build 9219" "The Fype Users Manual Page"
.SH "NAME"
\&\fBFype\fR is \fBF\fRor \fBY\fRour \fBP\fRrogram \fBE\fRxecution
.PP
\&\fBFype\fR is \fBF\fRree \fBY\fRak \fBP\fRrogramed for \fBE\fRLF
.PP
It's not a hype \- it's \fBFype\fR!
.SH "SYNOPSES"
.IX Header "SYNOPSES"
.IP "\fBfype\fR [\-[hsvTV]] file.fy" 4
.IX Item "fype [-[hsvTV]] file.fy"
.PD 0
.ie n .IP "\fBfype\fR \-e ""fype code string;""" 4
.el .IP "\fBfype\fR \-e ``fype code string;''" 4
.IX Item "fype -e fype code string;"
.PD
.SH "ABOUT"
.IX Header "ABOUT"
Fype is not yet released! Lots of basic stuff is still missing! See the
\&\s-1TODO\s0 file of the source distribution of Fype!
.PP
Fype is a 32 bit scripting language created for fun. You can use it and comment on it if you like. You could also write patches and mail them to fype at dev dot buetow dot org! Or go visit the \s-1IRC\s0 channel #coding at irc.german\-elite.net and ask rantanplan.
.PP
Fype is developed under the \s-1BSD\s0 license. See the \s-1COPYING\s0 file which is included in the source tree.
.PP
Fype should be \*(L"at least as good as \s-1AWK\s0\*(R". This does not mean it will be a replacement for \s-1AWK\s0 but it should support functions, loops and arrays like \s-1AWK\s0 does but with a different syntax. It should also get extension support like \s-1AWK\s0 has. I am not talking about \s-1GNU\s0 \s-1AWK\s0 but about New \s-1AWK\s0, which is included in the *BSD distributions! Fype already has a few features which are not available in \s-1AWK\s0. However, \s-1AWK\s0 has still many features which are not available in Fype as well ;)
.PP
Fancy stuff like \s-1OOP\s0 or unicode or threading is not yet planed. But fancy stuff like function pointers and closures may be considered for one of the first releases of Fype :) 
.SH "PARSING / CODE GENERATION"
.IX Header "PARSING / CODE GENERATION"
The Fype syntax is very simple and is using a maximum look ahead of 1 and a very easy top down parsing. Fype is parsing and interpreting its code simultaneous. This means, that syntax errors are only detected during program runtime. 
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
Fype only has been tested on FreeBSD 7.0. Linux may work too. Windows support is not planned. But may work using Cygwin or \s-1SFU\s0. Linux users have to install pmake before compiling Fype!
.PP
You will need:
.PP
.Vb 2
\&        GNU GCC C Compiler (gcc.gnu.org)
\&        NetBSD Make aka pmake (GNU Make will not work)
.Ve
.PP
NetBSD Make is included in any *BSD and can be run with just \fBmake\fR.
.SH "GETTING STARTED"
.IX Header "GETTING STARTED"
On Linux: Extract, compile and install Fype:
.PP
.Vb 5
\&        tar xvjf fype.tar.bz2
\&        cd fype
\&        pmake
\&        sudo pmake install 
\&        pmake clean
.Ve
.PP
On FreeBSD: Extract, compile and install Fype:
.PP
.Vb 5
\&        tar xvjf fype.tar.bz2
\&        cd fype
\&        make
\&        sudo make install 
\&        make clean
.Ve
.PP
Run a .fy file:
.PP
.Vb 1
\&        fype test.fy
.Ve
.PP
See the ./examples subdir of the Fype source distribution for examples! See also fype \-h for a list of all options.
.SH "DATA TYPES"
.IX Header "DATA TYPES"
Fype uses auto type conversion. However, if you want to know what's going on you may take a look at the provided basic datatypes.
.Sh "The basic data types"
.IX Subsection "The basic data types"
.IP "\fIinteger\fR" 4
.IX Item "integer"
Specifies an integer number
.IP "\fIdouble\fR" 4
.IX Item "double"
Specifies a double number
.IP "\fIstring\fR" 4
.IX Item "string"
Specifies a string
.IP "\fInumber\fR" 4
.IX Item "number"
May be an integer or a double number
.IP "\fIany\fR" 4
.IX Item "any"
May be of any type above
.IP "\fIvoid\fR" 4
.IX Item "void"
No type
.IP "\fIidentifier\fR" 4
.IX Item "identifier"
It's a variable name or a procedure name or a function name
.Sh "Explicit type conversions"
.IX Subsection "Explicit type conversions"
.IP "(\fIinteger\fR) \fBinteger\fR \fIany\fR" 4
.IX Item "(integer) integer any"
Converts any type to an integer
.IP "(\fIdouble\fR) \fBdouble\fR \fIany\fR" 4
.IX Item "(double) double any"
Converts any type to a double
.IP "(\fIstring\fR) \fBstring\fR \fIany\fR" 4
.IX Item "(string) string any"
Converts any type to a string
.SH "SYNTAX"
.IX Header "SYNTAX"
.Sh "Comments"
.IX Subsection "Comments"
Text from a \fB#\fR character until the end of the current line is considered being a comment. Multi line comments may start with an \fB#*\fR and and with an \fB*#\fR anywhere. Exceptions are if those signs are inside of strings.
.Sh "Statements"
.IX Subsection "Statements"
A Fype program is a list of statements. Each keyword, expression or function call is part of a statement. Each statement is ended with a semicolon. Example:
.PP
.Vb 3
\&        my bar = 3, foo = 1 + 2; 
\&        say foo;
\&        exit foo - bar;
.Ve
.Sh "Paranthesis"
.IX Subsection "Paranthesis"
All paranthesis of function calls are optional. They help to make the code better readable. They also help to force precedences of expressions.
.Sh "Scopeing"
.IX Subsection "Scopeing"
A new scope starts with an { and ends with an }. An exception is a procedure, which does not use its own scope (see later in this manual). Control statements and functions support scopeings. Here is a small example how to use scopes:
.PP
.Vb 1
\&        my foo = 1;
.Ve
.PP
.Vb 5
\&        {
\&                # Prints out 1
\&                put defined foo;
\&                {
\&                        my bar = 2;
.Ve
.PP
.Vb 3
\&                        # Prints out 1
\&                        put defined bar;
\&                }
.Ve
.PP
.Vb 2
\&                # Prints out 0
\&                put defined bar;
.Ve
.PP
.Vb 2
\&                my baz = 3;
\&        }
.Ve
.PP
.Vb 2
\&        # Prints out 0
\&        say defined bar;
.Ve
.Sh "Control statements"
.IX Subsection "Control statements"
Fype knows the following control statements:
.IP "if \fI<expression\fR> { \fI<statements\fR> }" 4
.IX Item "if <expression> { <statements> }"
Runs the statements if the expression evaluates to a true value.
.IP "ifnot \fI<expression\fR> { \fI<statements\fR> }" 4
.IX Item "ifnot <expression> { <statements> }"
Runs the statements if the expression evaluates to a false value.
.IP "while \fI<expression\fR> { \fI<statements\fR> }" 4
.IX Item "while <expression> { <statements> }"
Runs the statements as long as the the expression evaluates to a true value.
.IP "until \fI<expression\fR> { \fI<statements\fR> }" 4
.IX Item "until <expression> { <statements> }"
Runs the statements as long as the the expression evaluates to a false value.
.SH "VARIABLES"
.IX Header "VARIABLES"
Variables can be defined with the \fBmy\fR keyword. If you don't assign a value during declaration, then it's using the default integer value 0.  Variables may be changed during program runtime. Variables may be deleted using the \fBundef\fR keyword! Example of defining variables:
.PP
.Vb 2
\&        my foo = 1 + 2;
\&        say foo;
.Ve
.PP
.Vb 3
\&        my bar = 12, baz = foo;
\&        say 1 + bar;
\&        say bar;
.Ve
.PP
.Vb 2
\&        my baz;
\&        say baz; # Will print out 0
.Ve
.PP
You may use the \fBdefined\fR keyword to check if an identifier has been defined or
not.
.PP
.Vb 3
\&        ifnot defined foo {
\&                say "No foo yet defined";
\&        }
.Ve
.PP
.Vb 1
\&        my foo = 1;
.Ve
.PP
.Vb 4
\&        if defined foo {
\&                put "foo is defined and has the value ";
\&                say foo;
\&        }
.Ve
.SH "SYNONYMS TO VARIABLES/IDENTIFIERS"
.IX Header "SYNONYMS TO VARIABLES/IDENTIFIERS"
Each variable can have as many synonyms as wished. A synonym is another name to access the content of a specific variable. Here is an example of how to use synomyms:
.PP
.Vb 3
\&        my foo = "foo";
\&        my bar = \efoo;
\&        foo = "bar";
.Ve
.PP
.Vb 2
\&        # The synonym variable should now also set to "bar"
\&        assert "bar" == bar;
.Ve
.PP
Synonyms can be used for all kind of identifiers. It's not limited to normal variables but can be also used for function and procedure names etc.
.SH "BUILT IN FUNCTIONS"
.IX Header "BUILT IN FUNCTIONS"
In Fype, operators are built in functions as well. The difference is, that they may be written in infix notation instead in front of the arguments. The types inside the () specify the return types.
.Sh "Math"
.IX Subsection "Math"
.IP "(\fIany\fR) \fIany\fR \fB+\fR \fIany\fR" 4
.IX Item "(any) any + any"
Special string behavior: A string will get auto convertet into an \fIinteger\fR.
.IP "(\fIany\fR) \fIany\fR \fB\-\fR \fIany\fR" 4
.IX Item "(any) any - any"
Special string behavior: A string will get auto convertet into an \fIinteger\fR.
.IP "(\fIany\fR) \fIany\fR \fB*\fR \fIany\fR" 4
.IX Item "(any) any * any"
Special string behavior: A string will get auto convertet into an \fIinteger\fR.
.IP "(\fIany\fR) \fIany\fR \fB/\fR \fIany\fR" 4
.IX Item "(any) any / any"
Special string behavior: A string will get auto convertet into an \fIinteger\fR.
.Sh "Conditional"
.IX Subsection "Conditional"
.IP "(\fIinteger\fR) \fIany\fR \fB==\fR \fIany\fR" 4
.IX Item "(integer) any == any"
.PD 0
.IP "(\fIinteger\fR) \fIany\fR \fB!=\fR \fIany\fR" 4
.IX Item "(integer) any != any"
.IP "(\fIinteger\fR) \fIany\fR \fB<=\fR \fIany\fR" 4
.IX Item "(integer) any <= any"
.IP "(\fIinteger\fR) \fIany\fR \fB>=\fR \fIany\fR" 4
.IX Item "(integer) any >= any"
.IP "(\fIinteger\fR) \fIany\fR \fB<\fR \fIany\fR" 4
.IX Item "(integer) any < any"
.IP "(\fIinteger\fR) \fIany\fR \fB>\fR \fIany\fR" 4
.IX Item "(integer) any > any"
.IP "(\fIinteger\fR) \fBnot\fR \fIany\fR" 4
.IX Item "(integer) not any"
.PD
.Sh "Definedness"
.IX Subsection "Definedness"
.IP "(\fIinteger\fR) \fBdefined\fR \fIidentifier\fR" 4
.IX Item "(integer) defined identifier"
Returns 1 if \fIidentifier\fR has been defined. Returns 0 else.
.IP "(\fIinteger\fR) \fBundef\fR \fIidentifier\fR" 4
.IX Item "(integer) undef identifier"
Tries to undefine/delete the \fIidentifier\fR. Returns 1 if success, otherwise 0 is returned.
.Sh "Bitwise"
.IX Subsection "Bitwise"
.IP "(\fIinteger\fR) \fIany\fR \fB:<\fR \fIany\fR" 4
.IX Item "(integer) any :< any"
.PD 0
.IP "(\fIinteger\fR) \fIany\fR \fB:>\fR \fIany\fR" 4
.IX Item "(integer) any :> any"
.IP "(\fIinteger\fR) \fIany\fR \fBand\fR \fIany\fR" 4
.IX Item "(integer) any and any"
.IP "(\fIinteger\fR) \fIany\fR \fBor\fR \fIany\fR" 4
.IX Item "(integer) any or any"
.IP "(\fIinteger\fR) \fIany\fR \fBxor\fR \fIany\fR" 4
.IX Item "(integer) any xor any"
.PD
.Sh "Numeric"
.IX Subsection "Numeric"
.IP "(\fInumber\fR) \fBneg\fR \fInumber\fR" 4
.IX Item "(number) neg number"
This function returns the negative value of \fIany\fR
.IP "(\fIinteger\fR) \fBno\fR [\fIinteger\fR]" 4
.IX Item "(integer) no [integer]"
This function returns 1 if the argument is 0, otherwise it will return 0! If no
argument is given, then 0 is returned!
.IP "(\fIinteger\fR) \fByes\fR [\fIinteger\fR]" 4
.IX Item "(integer) yes [integer]"
This function always returns 1. The parameter is optional. 
.Sp
.Vb 2
\&        # Prints out 1, because foo is not defined
\&        if yes { say no defined foo; }
.Ve
.Sh "System"
.IX Subsection "System"
.IP "(\fIvoid\fR) \fBend\fR" 4
.IX Item "(void) end"
Exits the program with the exit status of 0
.IP "(\fIvoid\fR) \fBexit\fR \fIinteger\fR" 4
.IX Item "(void) exit integer"
Exits the program with the specified exit status
.IP "(\fIinteger\fR) \fBfork\fR" 4
.IX Item "(integer) fork"
Fork forks a subprocess. It returns 0 for the child process and the pid of the
child process otherwise! Example:
.Sp
.Vb 1
\&        my pid = fork;
.Ve
.Sp
.Vb 3
\&        if pid {
\&                put "I am the parent process; child has the pid ";
\&                say pid;
.Ve
.Sp
.Vb 3
\&        } ifnot pid {
\&                say "I am the child process";
\&        }
.Ve
.IP "(\fIinteger\fR) \fBgc\fR" 4
.IX Item "(integer) gc"
Executes the garbage collector and returns the number of items freed! You may
wonder why most of the time it will return a value of 0! Fype tries to free not
needed memory asap. This may change in future versions in order to gain faster
execution of scripts!
.Sh "I/O"
.IX Subsection "I/O"
.IP "(\fIany\fR) \fBput\fR \fIany\fR" 4
.IX Item "(any) put any"
Prints out the argument
.IP "(\fIany\fR) \fBsay\fR \fIany\fR" 4
.IX Item "(any) say any"
Same as put, but also includes an ending newline 
.IP "(\fIvoid\fR) \fBln\fR" 4
.IX Item "(void) ln"
Just prints a newline
.SH "SELF DEFINING PROCEDURES AND FUNCTIONS"
.IX Header "SELF DEFINING PROCEDURES AND FUNCTIONS"
.Sh "Procedures"
.IX Subsection "Procedures"
A procedure can be defined with the \fBproc\fR keyword and deleted with the \fBundef\fR keyword.  A procedure does not return any value and does not support parameter passing. It's using already defined variables (e.g. global variables). A procedure does not have its own namespace. It's using the calling namespace. It is possible to define new variabes inside of a procedure in the current namespace.
.PP
.Vb 4
\&        proc foo {
\&                say 1 + a * 3 + b;
\&                my c = 6;
\&        }
.Ve
.PP
.Vb 1
\&        my a = 2, b = 4;
.Ve
.PP
.Vb 2
\&        foo; # Run the procedure. Print out "11\en"
\&        say c; # Print out "6\en";
.Ve
.Sh "Nested procedures"
.IX Subsection "Nested procedures"
It's possible to define procedures inside of procedures. Since procedures don't
have its own scope, nested procedures will be available to the current scope as
soon as the main procedure has run the first time. You may use the \fBdefined\fR
keyword in order to check if a procedure has been defined or not.
.PP
.Vb 2
\&        proc foo {
\&                say "I am foo";
.Ve
.PP
.Vb 5
\&                undef bar;
\&                proc bar {
\&                        say "I am bar";
\&                }
\&        }
.Ve
.PP
.Vb 3
\&        # Here bar would produce an error because 
\&        # the proc is not yet defined!
\&        # bar;
.Ve
.PP
.Vb 3
\&        foo; # Here the procedure foo will define the procedure bar!
\&        bar; # Now the procedure bar is defined!
\&        foo; # Here the procedure foo will redefine bar again!
.Ve
.Sh "Functions"
.IX Subsection "Functions"
A function should be defined with the \fBfunc\fR keyword and deleted with the \fBundef\fR keyword. Function not yet return values (will be changed in future versions) and supports not yet parameter passing (will be changed in future versions). It's using local (lexical scoped) variables. If a certain variable does not exist It's using already defined variables (e.g. one scope above). 
.PP
.Vb 4
\&        func foo {
\&                say 1 + a * 3 + b;
\&                my c = 6;
\&        }
.Ve
.PP
.Vb 1
\&        my a = 2, b = 4;
.Ve
.PP
.Vb 2
\&        foo; # Run the procedure. Print out "11\en"
\&        say c; # Will produce an error, because c is out of scoped!
.Ve
.Sh "Nested functions"
.IX Subsection "Nested functions"
Nested functions work the same way the nested procedures work, with the exception that nested functions will not be available any more after the function has been left!
.PP
.Vb 4
\&        func foo {
\&                func bar {
\&                        say "Hello i am nested";
\&                }
.Ve
.PP
.Vb 2
\&                bar; # Calling nested
\&        }
.Ve
.PP
.Vb 2
\&        foo;
\&        bar; # Will produce an error, because bar is out of scope!
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul C. Buetow (http://paul.buetow.org)
.SH "WEBSITE"
.IX Header "WEBSITE"
The Fype Language (http://fype.buetow.org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIawk\fR\|(1) \fIcc\fR\|(1) \fImake\fR\|(1)
